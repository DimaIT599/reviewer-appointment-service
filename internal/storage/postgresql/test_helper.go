package postgresql

import (
	"context"
	"fmt"
	"os"
	"strings"
	"testing"

	"github.com/jackc/pgx/v5/pgxpool"
)

// setupTestDB создает тестовое подключение к БД
func setupTestDB(t *testing.T) (*Storage, func()) {
	t.Helper()

	// Получаем параметры подключения из переменных окружения или используем дефолтные
	dbHost := os.Getenv("TEST_DB_HOST")
	if dbHost == "" {
		dbHost = "localhost"
	}

	dbPort := 5432
	if port := os.Getenv("TEST_DB_PORT"); port != "" {
		fmt.Sscanf(port, "%d", &dbPort)
	}

	dbUser := os.Getenv("TEST_DB_USER")
	if dbUser == "" {
		dbUser = "postgres"
	}

	dbPassword := os.Getenv("TEST_DB_PASSWORD")
	if dbPassword == "" {
		dbPassword = "postgres"
	}

	dbName := os.Getenv("TEST_DB_NAME")
	if dbName == "" {
		dbName = "reviewer_appointment_test"
	}

	ctx := context.Background()

	// Сначала подключаемся к postgres для создания тестовой БД
	adminConnStr := fmt.Sprintf("user=%s password=%s host=%s port=%d dbname=postgres sslmode=disable",
		dbUser, dbPassword, dbHost, dbPort)

	adminPool, err := pgxpool.New(ctx, adminConnStr)
	if err != nil {
		t.Fatalf("Failed to connect to admin database: %v", err)
	}
	defer adminPool.Close()

	// Проверяем существование БД и создаем если её нет
	var exists bool
	err = adminPool.QueryRow(ctx, 
		"SELECT EXISTS(SELECT 1 FROM pg_database WHERE datname = $1)", dbName).Scan(&exists)
	if err != nil {
		t.Logf("Warning: Could not check database existence: %v", err)
	}

	if !exists {
		_, err = adminPool.Exec(ctx, fmt.Sprintf("CREATE DATABASE %s", dbName))
		if err != nil {
			// Игнорируем ошибку если БД уже существует (race condition)
			if !isDBExistsError(err) {
				t.Logf("Warning: Could not create database: %v", err)
			}
		}
	}

	// Теперь подключаемся к тестовой БД
	// Используем connection string с sslmode=disable для тестов
	testConnStr := fmt.Sprintf("user=%s password=%s host=%s port=%d dbname=%s sslmode=disable",
		dbUser, dbPassword, dbHost, dbPort, dbName)

	poolConfig, err := pgxpool.ParseConfig(testConnStr)
	if err != nil {
		t.Fatalf("Failed to parse test database config: %v", err)
	}

	pool, err := pgxpool.NewWithConfig(ctx, poolConfig)
	if err != nil {
		t.Fatalf("Failed to create connection pool: %v", err)
	}

	if err := pool.Ping(ctx); err != nil {
		pool.Close()
		t.Fatalf("Failed to ping test database: %v", err)
	}

	storage := &Storage{DB: pool}

	// Очистка БД перед тестом
	cleanupDB(t, storage.DB)

	// Применяем миграции
	if err := runMigrations(storage.DB, ctx); err != nil {
		storage.Close()
		t.Fatalf("Failed to run migrations: %v", err)
	}

	// Функция очистки после теста
	teardown := func() {
		cleanupDB(t, storage.DB)
		storage.Close()
	}

	return storage, teardown
}

// isDBExistsError проверяет, является ли ошибка ошибкой "база данных уже существует"
func isDBExistsError(err error) bool {
	if err == nil {
		return false
	}
	errStr := strings.ToLower(err.Error())
	return strings.Contains(errStr, "already exists") || 
		   strings.Contains(errStr, "duplicate") ||
		   strings.Contains(errStr, "already exist")
}

// cleanupDB очищает все таблицы
func cleanupDB(t *testing.T, db *pgxpool.Pool) {
	t.Helper()
	ctx := context.Background()

	tables := []string{
		"pr_system.pr_reviewers",
		"pr_system.pull_requests",
		"pr_system.users",
		"pr_system.teams",
		"pr_system.statuses",
	}

	for _, table := range tables {
		_, err := db.Exec(ctx, fmt.Sprintf("TRUNCATE TABLE %s CASCADE", table))
		if err != nil {
			// Игнорируем ошибки если таблицы не существует
			continue
		}
	}

	// Вставляем статусы обратно
	_, _ = db.Exec(ctx, `
		INSERT INTO pr_system.statuses (id, name) 
		VALUES (1, 'OPEN'), (2, 'MERGED') 
		ON CONFLICT (name) DO NOTHING
	`)
}

// runMigrations применяет миграции
func runMigrations(db *pgxpool.Pool, ctx context.Context) error {
	migrationSQL := `
		CREATE SCHEMA IF NOT EXISTS pr_system;

		CREATE TABLE IF NOT EXISTS pr_system.statuses (
			id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			name VARCHAR(50) NOT NULL UNIQUE,
			created_at TIMESTAMPTZ DEFAULT NOW()
		);

		INSERT INTO pr_system.statuses (id, name) VALUES (1, 'OPEN'), (2, 'MERGED') ON CONFLICT (name) DO NOTHING;

		CREATE TABLE IF NOT EXISTS pr_system.teams (
			id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
			name VARCHAR(255) NOT NULL UNIQUE,
			created_at TIMESTAMPTZ DEFAULT NOW()
		);

		CREATE TABLE IF NOT EXISTS pr_system.users (
			id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
			user_id VARCHAR(255) NOT NULL UNIQUE,
			username VARCHAR(255) NOT NULL,
			is_active BOOLEAN DEFAULT TRUE NOT NULL,
			team_id BIGINT REFERENCES pr_system.teams(id),
			created_at TIMESTAMPTZ DEFAULT NOW()
		);

		CREATE INDEX IF NOT EXISTS idx_users_team_id ON pr_system.users(team_id);
		CREATE INDEX IF NOT EXISTS idx_users_is_active ON pr_system.users(is_active);

		CREATE TABLE IF NOT EXISTS pr_system.pull_requests (
			id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
			pull_request_id VARCHAR(255) NOT NULL UNIQUE,
			pull_request_name VARCHAR(255) NOT NULL,
			author_id BIGINT NOT NULL REFERENCES pr_system.users(id),
			status_id INTEGER DEFAULT 1 NOT NULL REFERENCES pr_system.statuses(id),
			merged_at TIMESTAMPTZ,
			created_at TIMESTAMPTZ DEFAULT NOW()
		);

		CREATE INDEX IF NOT EXISTS idx_pull_requests_author_id ON pr_system.pull_requests(author_id);
		CREATE INDEX IF NOT EXISTS idx_pull_requests_status_id ON pr_system.pull_requests(status_id);

		CREATE TABLE IF NOT EXISTS pr_system.pr_reviewers (
			id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
			pr_id BIGINT NOT NULL REFERENCES pr_system.pull_requests(id) ON DELETE CASCADE,
			reviewer_id BIGINT NOT NULL REFERENCES pr_system.users(id),
			assigned_at TIMESTAMPTZ DEFAULT NOW(),
			UNIQUE (pr_id, reviewer_id)
		);

		CREATE INDEX IF NOT EXISTS idx_pr_reviewers_reviewer_id ON pr_system.pr_reviewers(reviewer_id);
		CREATE INDEX IF NOT EXISTS idx_pr_reviewers_pr_id ON pr_system.pr_reviewers(pr_id);
	`

	_, err := db.Exec(ctx, migrationSQL)
	return err
}

